#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long;
use Term::ANSIColor;


$| = 1;

my $timestamp = make_timestamp();
my $logdir    = "$ENV{HOME}/.athena-builder/logs/$timestamp";
my $collect_system_info;
my $log_fh;



sub info {
	my $text = shift;
	print STDERR $text;

	write_to_log($text);
}

sub info_ok {
	my $text = shift;
	print STDERR color('bold green');
	print STDERR $text;
	print STDERR color('reset');

	write_to_log($text);
}

sub warning {
	my $text = shift;
	print STDERR color('bold red');
	print STDERR $text;
	print STDERR color('reset');

	write_to_log($text);
}

sub important {
	my $text = shift;
	print STDERR color('bold white');
	print STDERR $text;
	print STDERR color('reset');

	write_to_log($text);
}

sub debug {
	my $text = shift;
	write_to_log($text);
}

sub fatal {
	my $text = shift;

	write_to_log("FATAL ERROR!\n");
	write_to_log($text);


	if ( $collect_system_info ) {
		important("Collecting additional system info to aid with debugging...\n");
		read_from_cmd_into_file("$logdir/df"   , { fail_ok => 1}, "df");
		read_from_cmd_into_file("$logdir/uname", { fail_ok => 1}, "uname", "-a");
		read_from_cmd_into_file("$logdir/dmesg", { fail_ok => 1}, "dmesg");

		system("cp", "-v", "/proc/cpuinfo", "$logdir/cpuinfo");
		system("cp", "-v", "/proc/meminfo", "$logdir/meminfo");

	} else {
		important("To aid with debugging, please re-run with the --collect-info argument.\n");
	}

	close $log_fh;

	
	my $compressed = "athena-builder-error-$timestamp.tar.gz";
	system("tar", "-czf", $compressed, $logdir);


	print STDERR color('bold red');
	print STDERR "\nFatal error:\n";
	print STDERR $text;
	print STDERR "\n\n";
	print STDERR color('reset');
	print STDERR "Logs have been collected in ";
	print STDERR color('bold white');

	if ( -f $compressed ) {
		print STDERR "$compressed\n";
	} else {
		print STDERR "$logdir\n";
	}
	
	print STDERR "Please notify Dale Glass#8576 on Discord of this problem.\n";
	print STDERR color('reset');
	exit 1;
}

sub write_to_log {
	my $text = shift;

	if ( $log_fh && fileno($log_fh) ) {
		print $log_fh $text;
	}
}


my $data = {
	'custom' => {
		has_binary_qt_package  => 0,
		source_dependencies    => [ ],
		qt_source_dependencies => [ ],
		qt_version => '5.12.6',
		qt_patches => [
			'aec.patch',
			'mac-web-video.patch',
#			'qfloat16.patch',  # Doesn't apply against 5.12.6
			'qtscript-crash-fix.patch'
		],
		package_manager => 'none'
	},
	'ubuntu-16.04' => {
		has_binary_qt_package => 1,
		package_manager => 'apt',
		source_dependencies => [
			'libterm-readline-gnu-perl',
			'build-essential',
			'git',
			'make',
			'cmake',
			'python',
			'libdrm-dev',
			'mesa-common-dev',
			'mesa-utils',
			'libglvnd-dev',
			'libgl1-mesa-dev',
			'xdg-user-dirs',
			# Qt runtime
			'libdouble-conversion1', 'libxcb-xinerama0-dev',
			# Interface
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Misc
			'libasound2', 'libxmu-dev', 'libxi-dev', 'freeglut3-dev', 'libasound2-dev', 'libjack0', 'libjack-dev', 'libxrandr-dev', 'libudev-dev', 'libssl-dev', 'zlib1g-dev',
			# Server
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Docs
			'nodejs'
		]

	},
	'ubuntu-18.04' => {
		has_binary_qt_package => 1,
		package_manager => 'apt',
		source_dependencies => [
			'libterm-readline-gnu-perl',
			'build-essential',
			'git',
			'make',
			'cmake',
			'python',
			'libdrm-dev',
			'mesa-common-dev',
			'mesa-utils',
			'libglvnd-dev',
			'libgl1-mesa-dev',
			'xdg-user-dirs',
			# Qt runtime
			'libdouble-conversion1', 'libxcb-xinerama0-dev',
			# Interface
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Misc
			'libasound2', 'libxmu-dev', 'libxi-dev', 'freeglut3-dev', 'libasound2-dev', 'libjack0', 'libjack-dev', 'libxrandr-dev', 'libudev-dev', 'libssl-dev', 'zlib1g-dev',
			# Server
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Docs
			'nodejs'
		]

	},
	'ubuntu-19.10' => {
		has_binary_qt_package => 1,
		package_manager => 'apt',
		source_dependencies => [
			'libterm-readline-gnu-perl',
			'build-essential',
			'git',
			'make',
			'cmake',
			'python',
			'libdrm-dev',
			'mesa-common-dev',
			'mesa-utils',
			'libglvnd-dev',
			'libgl1-mesa-dev',
			'xdg-user-dirs',
			# Qt
			'libdouble-conversion-dev', 'libxcb-xinerama0-dev', 'libpcre2-16-0', 'libxcb-xinput0',
			# Interface
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Misc
			'libasound2', 'libxmu-dev', 'libxi-dev', 'freeglut3-dev', 'libasound2-dev', 'libjack0', 'libjack-dev', 'libxrandr-dev', 'libudev-dev', 'libssl-dev', 'zlib1g-dev',
			# Server
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Docs
			'nodejs'
		],
		qt_version => '5.12.6',
		qt_patches => [
			'aec.patch',
			'mac-web-video.patch',
#			'qfloat16.patch',  # Doesn't apply against 5.12.6
			'qtscript-crash-fix.patch'
		],
		qt_source_dependencies => [
			'autoconf',
			'automake',
			'autopoint',
			'autotools-dev',
			'debhelper',
			'default-libmysqlclient-dev',
			'dh-autoreconf',
			'dh-exec',
			'dh-strip-nondeterminism',
			'firebird-dev',
			'firebird3.0-common',
			'firebird3.0-common-doc',
			'freetds-common',
			'freetds-dev',
			'gir1.2-harfbuzz-0.0',
			'icu-devtools',
			'libatk-bridge2.0-dev',
			'libatk1.0-dev',
			'libatspi2.0-dev',
			'libcairo-script-interpreter2',
			'libcairo2-dev',
			'libct4',
			'libcups2-dev',
			'libcupsimage2-dev',
			'libdbus-1-dev',
			'libegl1-mesa-dev',
			'libepoxy-dev',
			'libevdev-dev',
			'libexpat1-dev',
			'libfbclient2',
			'libfile-stripnondeterminism-perl',
			'libfontconfig1-dev',
			'libfreetype6-dev',
			'libgbm-dev',
			'libgdk-pixbuf2.0-dev',
			'libgles2-mesa-dev',
			'libglib2.0-dev',
			'libglib2.0-dev-bin',
			'libgraphite2-dev',
			'libgtk-3-dev',
			'libharfbuzz-dev',
			'libharfbuzz-gobject0',
			'libib-util',
			'libicu-dev',
			'libinput-dev',
			'libjbig-dev',
			'libjpeg-dev',
			'libjpeg-turbo8-dev',
			'libjpeg8-dev',
			'libltdl-dev',
			'liblzma-dev',
			'libmtdev-dev',
			'libmysqlclient-dev',
			'libodbc1',
			'libpango1.0-dev',
			'libpcre16-3',
			'libpcre3-dev',
			'libpcre32-3',
			'libpcrecpp0v5',
			'libpixman-1-dev',
			'libpng-dev',
			'libpq-dev',
			'libpq5',
			'libproxy-dev',
			'libpulse-dev',
			'libqt5designer5',
			'libqt5designercomponents5',
			'libqt5help5',
			'libqt5positioning5',
			'libqt5printsupport5',
			'libqt5qml5',
			'libqt5quick5',
			'libqt5quickwidgets5',
			'libqt5sensors5',
			'libqt5sql5',
			'libqt5sql5-sqlite',
			'libqt5webchannel5',
			'libqt5webkit5',
			'libqt5xml5',
			'libsqlite3-dev',
			'libsybdb5',
			'libtiff-dev',
			'libtiff5-dev',
			'libtiffxx5',
			'libtommath1',
			'libtool',
			'libwacom-dev',
			'libwayland-bin',
			'libwayland-dev',
			'libxcb-icccm4-dev',
			'libxcb-image0-dev',
			'libxcb-keysyms1-dev',
			'libxcb-render-util0-dev',
			'libxcb-shm0-dev',
			'libxcb-xkb-dev',
			'libxcomposite-dev',
			'libxcursor-dev',
			'libxft-dev',
			'libxinerama-dev',
			'libxkbcommon-dev',
			'libxkbcommon-x11-dev',
			'libxtst-dev',
			'mysql-common',
			'odbcinst',
			'odbcinst1debian2',
			'pkg-kde-tools',
			'po-debconf',
			'qt5-assistant',
			'qtchooser',
			'qttools5-dev-tools',
			'unixodbc-dev',
			'wayland-protocols',
			'x11proto-composite-dev',
			'x11proto-record-dev',
			# Also required
			'gperf',
			'bison',
			'flex',
			# Extra
			'libjsoncpp-dev',
			'libnss3-dev',
			'libvpx-dev',
			'libopus-dev',
			]

	},
	'linuxmint-19.3' => {
		# Based on Ubuntu 18.04 (bionic)
		has_binary_qt_package => 0,
		package_manager => 'apt',
		qt_version => '5.12.6',
		qt_patches => [
			'aec.patch',
			'mac-web-video.patch',
#			'qfloat16.patch',  # Doesn't apply against 5.12.6
			'qtscript-crash-fix.patch'
		],
		source_dependencies => [
			'libterm-readline-gnu-perl',
			'build-essential',
			'git',
			'make',
			'cmake',
			'python',
			'libdrm-dev',
			'mesa-common-dev',
			'mesa-utils',
			'libglvnd-dev',
			'libgl1-mesa-dev',
			'xdg-user-dirs',
			# Qt
			'libdouble-conversion-dev', 'libxcb-xinerama0-dev', 'libpcre2-16-0', 'libxcb-xinput0',
			# Interface
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Misc
			'libasound2', 'libxmu-dev', 'libxi-dev', 'freeglut3-dev', 'libasound2-dev', 'libjack0', 'libjack-dev', 'libxrandr-dev', 'libudev-dev', 'libssl-dev', 'zlib1g-dev',
			# Server
			'libpulse0', 'libnss3', 'libnspr4', 'libfontconfig1', 'libxcursor1', 'libxcomposite1', 'libxtst6', 'libxslt1.1',
			# Docs
			'nodejs',
			'python3-distro'
		],
		qt_source_dependencies => [
			'autoconf',
			'automake',
			'autopoint',
			'autotools-dev',
			'debhelper',
			'default-libmysqlclient-dev',
			'dh-autoreconf',
			'dh-exec',
			'dh-strip-nondeterminism',
			'firebird-dev',
			'firebird3.0-common',
			'firebird3.0-common-doc',
			'freetds-common',
			'freetds-dev',
			'gir1.2-harfbuzz-0.0',
			'icu-devtools',
			'libatk-bridge2.0-dev',
			'libatk1.0-dev',
			'libatspi2.0-dev',
			'libcairo-script-interpreter2',
			'libcairo2-dev',
			'libct4',
			'libcups2-dev',
			'libcupsimage2-dev',
			'libdbus-1-dev',
			'libegl1-mesa-dev',
			'libepoxy-dev',
			'libevdev-dev',
			'libexpat1-dev',
			'libfbclient2',
			'libfile-stripnondeterminism-perl',
			'libfontconfig1-dev',
			'libfreetype6-dev',
			'libgbm-dev',
			'libgdk-pixbuf2.0-dev',
			'libgles2-mesa-dev',
			'libglib2.0-dev',
			'libglib2.0-dev-bin',
			'libgraphite2-dev',
			'libgtk-3-dev',
			'libharfbuzz-dev',
			'libharfbuzz-gobject0',
			'libib-util',
			'libicu-dev',
			'libicu-le-hb-dev',
			'libicu-le-hb0',
			'libiculx60',
			'libinput-dev',
			'libjbig-dev',
			'libjpeg-dev',
			'libjpeg-turbo8-dev',
			'libjpeg8-dev',
			'libltdl-dev',
			'liblzma-dev',
			'libmtdev-dev',
			'libmysqlclient-dev',
			'libmysqlclient20',
			'libodbc1',
			'libpango1.0-dev',
			'libpcre16-3',
			'libpcre3-dev',
			'libpcre32-3',
			'libpcrecpp0v5',
			'libpixman-1-dev',
			'libpng-dev',
			'libpq-dev',
			'libpq5',
			'libproxy-dev',
			'libpulse-dev',
			'libqt5designer5',
			'libqt5designercomponents5',
			'libqt5help5',
			'libqt5positioning5',
			'libqt5printsupport5',
			'libqt5qml5',
			'libqt5quick5',
			'libqt5quickwidgets5',
			'libqt5sensors5',
			'libqt5sql5',
			'libqt5sql5-sqlite',
			'libqt5webchannel5',
			'libqt5webkit5',
			'libqt5xml5',
			'libsqlite3-dev',
			'libsybdb5',
			'libtiff-dev',
			'libtiff5-dev',
			'libtiffxx5',
			'libtommath1',
			'libtool',
			'libwacom-dev',
			'libwayland-bin',
			'libwayland-dev',
			'libxcb-icccm4-dev',
			'libxcb-image0-dev',
			'libxcb-keysyms1-dev',
			'libxcb-render-util0-dev',
			'libxcb-shm0-dev',
			'libxcb-xkb-dev',
			'libxcomposite-dev',
			'libxcursor-dev',
			'libxft-dev',
			'libxinerama-dev',
			'libxkbcommon-dev',
			'libxkbcommon-x11-dev',
			'libxtst-dev',
			'mysql-common',
			'odbcinst',
			'odbcinst1debian2',
			'pkg-kde-tools',
			'po-debconf',
			'qt5-assistant',
			'qtchooser',
			'qttools5-dev-tools',
			'unixodbc-dev',
			'wayland-protocols',
			'x11proto-composite-dev',
			'x11proto-record-dev',
			# Also required
			'gperf',
			# Extra
			'libjsoncpp-dev',
			'libnss3-dev',
			'libvpx-dev',
			'libopus-dev',
		]
	},
	'fedora-31' => {
		has_binary_qt_package => 0,
		qt_version => '5.12.6',
		qt_patches => [
			'aec.patch',
			'mac-web-video.patch',
#			'qfloat16.patch',  # Doesn't apply against 5.12.6
			'qtscript-crash-fix.patch'
		],
		package_manager => 'dnf',
		source_dependencies => [
			'git',
			'perl-Term-ReadLine-Gnu',
			'cmake',
			'make',
			'gcc-c++',
			'libatomic'
		],
		qt_source_dependencies => [
			"patch",
			"alsa-lib-devel",
			"cups-devel",
			"firebird-devel",
			"freetds-devel",
			"glib2-devel",
			"gtk3-devel",
			"libdrm-devel",
			"libinput-devel",
			"libjpeg-turbo-devel",
			"libpq-devel",
			"libtiff-devel",
			"libxkbcommon-devel",
			"libxkbcommon-x11-devel",
			"mariadb-connector-c-devel",
			"mesa-libEGL-devel",
			"mesa-libGL-devel",
			"mesa-libgbm-devel",
			"pcre2-devel",
			"sqlite-devel",
			"systemd-devel",
			"xkeyboard-config-devel",
			"zlib-devel",
			"at-spi2-core-devel",
			"dbus-devel",
			"fontconfig-devel",
			"harfbuzz-devel",
			"libICE-devel",
			"libSM-devel",
			"libicu-devel",
			"libmng-devel",
			"libpng-devel",
			"libproxy-devel",
			"libxcb-devel",
			"openssl-devel",
			"pcre-devel",
			"perl-generators",
			"pulseaudio-libs-devel",
			"qt5-rpm-macros",
			"unixODBC-devel",
			"xcb-util-image-devel",
			"xcb-util-keysyms-devel",
			"xcb-util-renderutil-devel",
			"xcb-util-wm-devel",
			"libxcb-devel",
			"python2",
			"gperf",
			"bison",
			"flex",
			"nss-devel",
			"libstdc++-static",
			# Possibly unnecessary, optional dependencies of
			# WebEngine. Should check what's useful and what not.
			"jsoncpp-devel",
			"libxslt-devel",
			"libvpx-devel",
			"libicu-devel",
			"re2-devel",
			"libxml2-devel",
			"opus-devel",
			"libicu-devel",
			"libwebp-devel"
		]
	}
};

my @x11_lib_paths = ("/usr/lib64", "/usr/X11R6/lib64", "/usr/lib/x86_64-linux-gnu", "/usr/lib");

# Amount of RAM needed to build Athena, per compiler process.
my $mem_per_core_athena = 1 * 1024 * 1024;

# Qt has a build stage that consumes a huge amount of RAM. Be a bit conservative here.
my $mem_per_core_qt     = 1.2 * 1024 * 1024;

my $repo         = "https://github.com/kasenvr/project-athena";
my $qt_repo      = "git://code.qt.io/qt/qt5.git";
my $repo_tag     = "kasen/core";
my $inst_dir     = "$ENV{HOME}/Athena";
my $build_cores;
my $build_cores_qt;

my $desktop;
my $distro;

my ($opt_keep_source, $opt_auto, $opt_build_qt, $opt_build);
my ($cmd_help, $cmd_get_supported, $cmd_get_source_deps, $cmd_get_qt_deps, $cmd_get_qt_version, $cmd_get_qt_patches, $cmd_make_pkglist);

$opt_build = "interface";
my @build_list;


GetOptions(
	"keep-source|K"          => \$opt_keep_source,
	"help|h"                 => \$cmd_help,
	"auto|y"                 => \$opt_auto,
	"repo|r=s"               => \$repo,
	"tag|t=s"                => \$repo_tag,
        "destdir|d=s"            => \$inst_dir,
        "cores|j=i"              => \$build_cores,
	"collect-info|C"         => \$collect_system_info,
	"distro|D=s"             => \$distro,
	"build-qt|B"             => \$opt_build_qt,
	"build|U=s"              => \$opt_build,
	"get-supported"          => \$cmd_get_supported,
	"get-source-deps=s"      => \$cmd_get_source_deps,
	"get-qt-deps=s"          => \$cmd_get_qt_deps,
	"get-qt-version=s"       => \$cmd_get_qt_version,
	"get-qt-patches=s"       => \$cmd_get_qt_patches,
	"make-pkglist"           => \$cmd_make_pkglist
) or help(1);


@build_list = parse_build_option($opt_build);

help(1) if ($cmd_help);

get_supported() if ( $cmd_get_supported );
get_conf( 'source_dependencies', $cmd_get_source_deps ) if ( $cmd_get_source_deps );
get_conf( 'qt_source_dependencies', $cmd_get_qt_deps )  if ( $cmd_get_qt_deps );
get_conf( 'qt_version', $cmd_get_qt_version )           if ( $cmd_get_qt_version );
get_conf( 'qt_patches', $cmd_get_qt_patches )           if ( $cmd_get_qt_patches );
make_pkglist()                                          if ( $cmd_make_pkglist );




mkdir("$ENV{HOME}/.athena-builder");
mkdir("$ENV{HOME}/.athena-builder/logs");
mkdir($logdir);

open($log_fh, ">", "$logdir/log.txt") or warn("Couldn't create log '$logdir/log.txt': $!");


$build_cores    //= calculate_cores("Athena", $mem_per_core_athena);
$build_cores_qt //= calculate_cores("Qt", $mem_per_core_qt);
$desktop        //= get_desktop();
$distro         //= detect_distro();


if ( !exists $data->{$distro} ) {
	fatal("No configuration for $distro, distribution unsupported.");
}

my $DD = $data->{$distro};



my %PACKAGES = get_package_list();
install_missing_packages();
collect_info();

get_source();
install_qt() if (!$DD->{has_binary_qt_package} || $opt_build_qt);
install();
setup_desktop();




sub detect_distro {
	info("Detecting distribution... ");

	if ( -f "/etc/fedora-release" ) {
		my ($release_line) = readfile("/etc/fedora-release");
		my ($ver) = $release_line =~ /^Fedora release (\d+)/;

		info_ok("Fedora $ver\n");
		return "fedora-$ver";
	}

	if ( -f "/etc/lsb-release" ) {
		my @lsb = readfile("/etc/lsb-release");
		my ($dist) = grep { /^DISTRIB_ID/ } @lsb;
		my ($ver)  = grep { /^DISTRIB_RELEASE/ } @lsb;

		my ($distro_name, $release);
		(undef, $distro_name) = split(/=/, $dist);
		(undef, $release)     = split(/=/, $ver);

		info_ok("$distro_name $release\n");
		return lc($distro_name) . "-$release";
	}

	fatal("Failed to detect distribution!");
}



sub get_package_list {
	info("Getting the package list... ");
	my @packages;
	if ( $DD->{package_manager} eq "dnf" ) {
		@packages = read_from_cmd("rpm", "-qa", "--qf", "%{NAME}\\n");
	} elsif ( $DD->{package_manager} eq "apt" ) {
		@packages = read_from_cmd("dpkg-query", "--show", "-f", "\${Package}\n");
	} elsif ( $DD->{package_manager} eq "none" ) {
		# Nothing
	} else {
		fatal("Internal error: unknown package manager " . $DD->{package_manager});
	}

	chomp @packages;

	info_ok("done.\n");
	return map { $_ => 1 } @packages;
}

sub install_missing_packages {
	my @required_packages = @{$DD->{source_dependencies}};

	info("Checking Qt availability...");


	if ( !$DD->{has_binary_qt_package} || $opt_build_qt ) {
		if( !$DD->{has_binary_qt_package} ) {
			warning("There is no binary Qt package available for your system!\n\n");
			warning("This script can build it for you, but it can take a long time,\n");
			warning("up to several hours, depending on hardware capabilities.\n\n");
			warning("Fortunately, it only needs to be built once.\n\n");
		} else {
			info_ok("Qt source build selected by user.\n");
		}
		push @required_packages, @{ $DD->{qt_source_dependencies} }
	} else {
		info_ok(" yes\n");
	}




	info("Checking if any packages need installing... ");


	my @missing = grep { !exists $PACKAGES{$_} } @required_packages;


	if ( @missing ) {
		print scalar(@missing) . " additional packages needed: " . join(", ", @missing) . "\n";

		if ( $DD->{package_manager} eq "dnf" ) {
			sudo_run("dnf", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "apt" ) {
			sudo_run("apt-get", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "none" ) {
			# Nothing
		} else {
			fatal("Internal error: unknown package manager " . $DD->{package_manager});
		}

		info_ok("\nPackages have been installed, please run $0 again.\n\n");
		exit(0);
	} else {
		info_ok("no.\n");
	}
}

sub collect_info {
	require Term::ReadLine;
	info("\n");
	important("Everything seems to be in order. I am going to ask you some questions now.\n");
	important("The defaults should be just fine. Simply press ENTER to accept the suggested\n");
	important("value.\n\n");

	my $rl = Term::ReadLine->new('athena_setup');
	my $ok = $opt_auto ? "yes" : "no";

	while($ok ne "yes") {
		$repo            = $rl->readline("Git repository             : ", $repo);
		$repo_tag        = $rl->readline("Git tag                    : ", $repo_tag);
		$inst_dir        = $rl->readline("Installation dir           : ", $inst_dir);
		$build_cores     = $rl->readline("CPU cores to use for Athena: ", $build_cores);
		$build_cores_qt  = $rl->readline("CPU cores to use for Qt5   : ", $build_cores_qt);

		info("\n");
		$ok = $rl->readline("If the above is okay, say 'yes' to begin installation: ", "yes");
	}


}


sub get_source {
	info("\n\n");
	important("############################################################\n");
	important("# Starting installation\n");
	important("############################################################\n");
	info("\n");

	mkdir($inst_dir);
	
	clone_repo($repo, "source", $repo_tag);
}

sub install {
	info("\n\n");
	important("############################################################\n");
	important("# Building\n");
	important("############################################################\n");
	info("\n");


	if ( check_qt_install() ) {
		important("Using compiled Qt\n");
		$ENV{QT_CMAKE_PREFIX_PATH}="$inst_dir/qt5-install/lib/cmake";
	}	


	$ENV{HIFI_VCPKG_BASE} = "$inst_dir/vcpkg";

	if ( -d "$inst_dir/build" ) {
		run("rm", "-rf", "$inst_dir/build");
	}

	mkdir("$inst_dir/build");
	chdir("$inst_dir/build");

	run("cmake", "../source");
	foreach my $target (@build_list) {
		important("Building target $target\n");
		run("make", $target, "-j${build_cores}");
	}
	

}


sub install_qt {

	if ( check_qt_install() ) {
		important("Skipping Qt5 build. You can remove $inst_dir/qt5-install if you want to force it to be rebuilt.\n");
		return;
	}


	info("\n\n");
	important("############################################################\n");
	important("# Starting Qt build\n");
	important("############################################################\n");
	info("\n");


	mkdir($inst_dir);
	chdir($inst_dir);
#	run("git", "clone", "--recursive", $qt_repo
	clone_repo($qt_repo, "qt5",  $DD->{qt_version});


	info("Applying patches...\n");
	chdir("$inst_dir/qt5");

	foreach my $patch ( @{ $DD->{qt_patches} } ) {
		run("patch", "-p1", "-i", "$inst_dir/source/tools/qt-builder/patches/$patch");
	}

	info("Configuring paths...\n");
	my $xlib_path  = find_lib_dir('libX11.so', @x11_lib_paths);
	my $gllib_path = find_lib_dir('libGL.so', @x11_lib_paths);

	edit_qt_conf(
		"$inst_dir/qt5/qtbase/mkspecs/linux-g++-64/qmake.conf",
		QMAKE_LIBDIR_X11    => $xlib_path,
		QMAKE_LIBDIR_OPENGL => $gllib_path
	);
		


	del_dir("$inst_dir/qt5-install");
	del_dir("$inst_dir/qt5-build");

	mkdir("$inst_dir/qt5-install");
	mkdir("$inst_dir/qt5-build");

	chdir("$inst_dir/qt5-build");

	# The build process calls Ninja for QtWebEngine, which calculates the number of processes
	# on its own. Fortunately there's an environment variable we can use to rein it in.
	#
	# This var can be found referenced in
	# qtwebengine/src/core/gn_run.pro
	$ENV{NINJAFLAGS} = "-j${build_cores_qt}";

	run("../qt5/configure", "-opensource", "-confirm-license", 
		"-platform", "linux-g++-64",
		"-nomake", "examples",
		"-nomake", "tests",
		"-skip", "qttranslations",
		"-skip", "qtserialport",
		"-skip", "qt3d",
		"-skip", "qtlocation",
		"-skip", "qtwayland",
		"-skip", "qtsensors",
		"-skip", "qtgamepad",
		"-skip", "qtspeech",
		"-skip", "qtcharts",
		"-skip", "qtmacextras",
		"-skip", "qtvirtualkeyboard",
		"-skip", "qtpurchasing",
		"-skip", "qtdatavis3d",
		"-no-warnings-are-errors", "-no-pch", "-opengl", "-xcb-xlib", "-no-egl", "-no-icu",
		"-prefix", "../qt5-install");

	check_qt_webengine();
	run("make", "-j${build_cores_qt}");
	run("make", "-j${build_cores_qt}", "install");



}

sub setup_desktop {


	if ( ! -x "$inst_dir/build/interface/interface" ) {
		info("interface not built, skipping desktop setup\n");
		return;
	}

	if (!check_qt_install()) {
		my $qt_dir = read_from_cmd("find", "$inst_dir/vcpkg", "-type", "d", "-name", "qt5-install");
		chomp $qt_dir;

		if ( -d "$qt_dir" ) {
			info("Creating permanent qt dir... ");
			if ( -d "$inst_dir/qt5-install" ) {
				run("rm", "-rf", "$inst_dir/qt5-install");
			}
			run("cp", "-Rdp", $qt_dir, "$inst_dir/qt5-install");
		
			info_ok("done.\n");
		} else {
			fatal("Failed to find Qt dir in $inst_dir/vcpkg!");
		}
	}


	info("Creating desktop icon for interface... ");

	open(my $script, ">", "$inst_dir/build/run_interface") or fatal("Can't create $inst_dir/build/interface: $!");
	print $script "#!/bin/bash\n";
	print $script "export QT_DIR=$inst_dir/qt5-install\n";
	print $script "export QT_QPA_PLATFORM_PLUGIN_PATH=\$QT_DIR/plugins\n";
	print $script "export LD_LIBRARY_PATH=\$QT_DIR/lib:\$LD_LIBRARY_PATH\n";
	print $script "export PATH=\$QT_DIR/bin:\$QT_DIR/libexec:\$PATH\n";
	print $script "export QTWEBENGINEPROCESS_PATH=\$QT_DIR/libexec/QtWebEngineProcess\n";
	print $script "\"$inst_dir/build/interface/interface\" \"\$@\" 2>&1 | tee -a \"$inst_dir/build/interface.log\"\n";
	close $script;
	chmod 0755,  "$inst_dir/build/run_interface";


	open(my $dsk, ">", "$desktop/Athena.desktop") or fatal("Can't create $desktop/Athena.desktop: $!");
	print $dsk "[Desktop Entry]\n";
	print $dsk "Version=1.0\n";
	print $dsk "Name=Athena VR\n";
	print $dsk "Terminal=false\n";
	print $dsk "Type=Application\n";
	print $dsk "Exec=$inst_dir/build/run_interface\n";
	print $dsk "Icon=$inst_dir/source/interface/icon/interface.ico\n";
	print $dsk "Categories=Graphics;AudioVideo;Network\n";
	close $dsk;

	info_ok("done.\n");

	info("Marking desktop icon as trusted...\n");
	run({ fail_ok => 1 }, "gio", "set", "$desktop/Athena.desktop", "metadata::trusted", "yes");

	info("Adding to menu...\n");
	run({ fail_ok => 1 }, "xdg-desktop-menu", "install", "--novendor", "$desktop/Athena.desktop");

	info_ok("All done!\n");
}


sub error_to_text {
	my ($retval, $errstr, $exec_failed) = @_;

	if ( $retval == -1 ) {
		return "failed to execute: $errstr";
	} elsif ( $retval & 127 ) {
		return sprintf("died with signal %d, %s coredump",
			($retval & 127), ( $retval & 128 ) ? 'with' : 'without');
	} else {
		if ( $exec_failed ) {
			return "failed to start with error '$errstr'";
		} else {
			return sprintf("exited with value %d", $retval >> 8)
		}
	}
}

sub secs_to_time {
	my ($secs) = @_;

	## Avoid POSIX::floor -- maybe unnecessarily?
	my $hours = sprintf("%d", $secs / 3600);
	$secs -= ($hours*3600);

	my $mins = sprintf("%d", $secs / 60);
	$secs -= ($mins * 60);

	return sprintf("%d:%02d:%02d", $hours, $mins, $secs);
}

sub run {
	my (@command) = @_;
	my %opts;

	if ( ref($command[0]) eq "HASH" ) {
		%opts = %{ shift(@command) }
	}

	my $cmdstr = join(' ', @command);
	debug("RUN: $cmdstr\n");
	my $buf = "";
	my $start = time;


	if ( open(my $fh, "-|", @command) ) {
		while(my $line = <$fh>) {
			$buf .= $line if ( $opts{keep_buf} );
			print $line unless ( $opts{keep_buf} );
			debug($line);
		}
		close $fh;
		my $retval = $?;
		my $errstr = $!;

		debug("\nCommand '$cmdstr' " . error_to_text($retval, $errstr) . "  after " . secs_to_time(time - $start) . "\n");

		if ( $retval != 0 ) {
			if ( $opts{fail_ok} ) {
				warning( "Command '$cmdstr' " . error_to_text($?, $!) . "\n" );
			} else {
				fatal( "Command '$cmdstr' " . error_to_text($?, $!) . "\n" );
			}
		}
	} else {
		if ( $opts{fail_ok} ) {
			warning("Failed to run '$cmdstr'. Command " . error_to_text($?, $!, 1) . "\n");
		} else {
			fatal("Failed to run '$cmdstr'. Command " . error_to_text($?, $!, 1) . "\n");
		}
	}

	return  wantarray ? split(/\n/, $buf) : $buf;
}

sub sudo_run {
	my (@command) = @_;

	important("Root privileges are needed to run the following command:\n");
	important("\t" . join(' ', @command) . "\n");
	important("Please enter your password to continue\n\n");

	run("sudo", @command);
}

sub read_from_cmd {
	my (@command) = @_;
	my $opts = {};

	if ( ref($command[0]) eq "HASH" ) {
		$opts = shift(@command);
	}

	$opts->{keep_buf} = 1;

	return run($opts, @command);
}

sub read_from_cmd_into_file {
	my ($filename, @cmd) = @_;
	my $text = read_from_cmd(@cmd);

	# die instead of fatal() here since this may be called from fatal.
	open(my $fh, '>', $filename) or die "Failed to create $filename: $!";
	print $fh $text;
	close $fh;
}



sub calculate_cores {
	my ($name, $mem_per_core) = @_;
	info("Checking how many cores to use for building $name... ");

	my $core_count =  grep { /^processor/ } readfile("/proc/cpuinfo");
	my ($mem_avail) = grep { /^MemAvailable/ } readfile("/proc/meminfo");

	info_ok("$core_count cores");

	$mem_avail =~ /:\s*(\d+)/;
	$mem_avail = $1;

	
	my $cores = $core_count;
	if ( $cores >= ($mem_avail / $mem_per_core )) {
		$cores = int($mem_avail / $mem_per_core);
		$cores = 1 unless ($cores);
		warning(", memory limited to $cores");

	}
	info_ok("\n");

	return $cores;
}

sub get_desktop {
	info("Detecting desktop location... ");

	my $desktop = read_from_cmd("xdg-user-dir", "DESKTOP");
	if (!$desktop) {
		$desktop = "$ENV{HOME}/Desktop";
	}

	chomp $desktop;
	info_ok($desktop . "\n");

	return $desktop;
}


sub readfile {
	my ($file) = @_;
	debug("READFILE: $file\n");

	open(my $fh, $file) or fatal("Can't open $file: $!");
	my @data = <$fh>;
	chomp @data;
	close $fh;

	debug(join("\n", @data));
	return @data;
}

sub clone_repo {
	my ($url, $destdir, $tag, %opts) = @_;

	info("Cloning $url ($tag)... ");

	if ( ! -d "$inst_dir/$destdir/.git" ) {
		my @git_extra_args;
		info("\n");

		if ( exists $opts{git_args} ) {
			@git_extra_args = @{$opts{git_args}};
		}

		run("git", "clone", "--recursive", $url, "$inst_dir/$destdir", "-b", $tag, "--single-branch"); # "@git_extra_args);

	} else {
		info_ok("Already cloned, updating...\n");

		if ( !$opt_keep_source ) {
			chdir("$inst_dir/$destdir");
			run("git", "fetch");
			run("git", "submodule", "update", "-f", "--init");
			run("git", "clean", "-f");
			run("git", "reset", "--hard", $tag);
		}
	}
}
	

sub edit_qt_conf {
	my ($file, %values) = @_;

	info("Editing qt config file $file... ");

	open(my $rh, "<", $file) or fatal("Failed to open $file: $!");
	open(my $wh, ">", "$file.new") or fatal("Failed to create $file.new: $!");
	while(my $line = <$rh>) {
		if ( $line =~ /^(\w+)\s*=\s*(.*?)$/ && exists $values{$1} ) {
			print $wh "$1=$values{$1}\n";
			delete $values{$1};
		} else {
			print $wh $line;
		}
	}

	close $wh;
	close $rh;

	rename("$file.new", $file) or fatal("Failed to rename $file.new to $file: $!");

	if ( %values ) {
		fatal("Failed to find settings when editing $file: " . join(', ', keys %values));
	}

	info_ok("done.\n");
}


sub find_lib_dir {
	my ($lib, @paths) = @_;
	info("Trying to find where $lib is... ");
	foreach my $dir (@paths) {
		if ( -f "$dir/$lib" || -l "$dir/$lib" ) {
			info_ok("Found in $dir\n");
			return $dir;
		}
	}

	fatal("Failed! Looked in: " . join(', ', @paths));
}

sub del_dir {
	my ($dir) = @_;

	info("Ensuring $dir doesn't exist... ");
	if ( -d "$dir" ) {
		run("rm", "-rf", $dir);
		info_ok("deleted.\n");
	} else {
		info_ok("ok.\n");
	}
}


sub check_qt_install {
	info("Checking whether Qt is already installed... ");

	if ( -f "$inst_dir/qt5-install/lib/libQt5Widgets.so" || -l "$inst_dir/qt5-install/lib/libQt5Widgets.so" ) {
		info_ok("yes.\n");
		return 1;
	} else {
		info_ok("no.\n");
		return 0;
	}
}

sub check_qt_webengine {
	# This checks if QtWebEngine is going to be built, and if any required dependencies
	# are missing. This works by parsing config.summary, which seems very clunky.
	#
	# This is necessary because Qt will build fine without WebEngine, but then
	# the interface will fail to build.
	#
	# Improvements are welcome.

	info("Checking QtWebEngine configuration... ");

	open(my $fh, '<', "$inst_dir/qt5-build/config.summary")
		or fatal("Can't open $inst_dir/qt5-build/config.summary: $!");



	my $sections_found = 0;
	my $lines_found = 0;

	my $in_webengine;
	my $in_req;
	my $in_req_sys_qpa;
	my @missing;


	while(my $line = <$fh>) {
		chomp $line;


		if ( $line =~ /^WARNING: (.*?) is required to build QtWebEngine/ ) {
			push @missing, $1;
		}

		if ( $line !~ /^\s+/ || $line =~ /^\s*$/ ) {
			# Line doesn't start with a space, or the line is empty
			undef $in_webengine;
			undef $in_req;
		}

		if ( $line !~ /^\s{4}/ ) {
			undef $in_req;
		}

		if ( $line =~ /^Qt WebEngine:/ ) {
			$in_webengine = 1;
			$sections_found++;
			next;
		}

		if ( $in_webengine && $line =~ /^  Required/ ) {
			$in_req = 1;
			$sections_found++;
			next;
		}

		if ( $in_req ) {
			if ( $line =~ /^\s*(.*?)[ .]+(\w+)$/ ) {
				$lines_found++;

				my ( $dep, $val ) = ($1, $2);
				if ( $val =~ /no/i ) {
					push @missing, $dep;
				}
			} else {
				fatal("Failed to parse line '$line' in $inst_dir/qt5-build/config.summary");
			}
		}

	}
	close $fh;

	if ($sections_found < 3) {
		fatal("Failed to parse $inst_dir/qt5-build/config.summary: only $sections_found of 3 sections were found");
	}

	if ($lines_found < 5) {
		# There are 11 lines in Qt 5.12.6.
		# We don't care about the exact amount, just that something matched and the result is plausible.
		fatal("Failed to parse $inst_dir/qt5-build/config.summary: only $lines_found lines were found inside the sections");
	}


	if (@missing) {
		fatal("Missing QtWebEngine dependencies: " . join(', ', @missing));
	} else {
		info_ok("ok.\n");
	}
}

sub make_timestamp {
	# Avoid need for strftime
	my ($sec, $min, $hour, $mday, $month, $year) = localtime(time);
	return sprintf("%04i-%02i-%02i_T%02i_%02i_%02i", $year + 1900, $month, $mday, $hour, $min, $sec);
}


sub get_supported {
	foreach my $k ( keys %$data ) {
		print "$k\n";
	}
	exit(0);
}

sub get_conf {
	my ($key, $dist) = @_;
	unless(exists $data->{$dist}) {
		print STDERR "No such distribution: '$dist'. Try $0 --get-supported\n";
		exit(1);
	}

	unless( exists $data->{$dist}->{$key} ) {
		print STDERR "$key not defined in the config for distro '$dist'\n";
		exit(1);
	}


	if ( ref($data->{$dist}->{$key}) eq "ARRAY" ) {
		foreach my $pkg ( @{ $data->{$dist}->{$key} } ) {
			print "$pkg\n";
		}
	} else {
		print $data->{$dist}->{$key} . "\n";
	}

	exit(0);
}

sub make_pkglist {
	my @packages;
	while(my $line = <STDIN>) {
		chomp $line;
		my @pkgs = grep { $_ } split(/\s+/, $line);
		push @packages, @pkgs;
	}

	foreach my $pkg ( sort @packages ) {
		print "\t\t\t\'$pkg',\n";
	}

	exit(0);
}

sub parse_build_option {
	my ($optval) = @_;


	# Valid build targets for the makefile
	my @all_targets = qw(  domain-server assignment-client ice-server
	                       interface atp-client oven nitpick skeleton-dump
	                       ac-client ktx-tool ice-client gpu-frame-player
	                       vhacd-util
	                    );

	# Valid aliases (names for groups of targets)
	my @all_aliases = qw( all client server );

	my %all_valid = map { $_ => 1 } (@all_aliases, @all_targets);
	my %split = map { $_ => 1 } split(/,/, $optval);
	my @out;

	if ( $split{all} ) {
		delete $split{all};
		foreach my $t (@all_targets) {
			$split{$t} = 1;
		}
	}

	if ( $split{client} ) {
		delete $split{client};
		$split{'interface'}        = 1;
	}

	if ( $split{server} ) {
		delete $split{server};
		$split{'domain-server'}     = 1;
		$split{'assignment-client'} = 1;
	}

	foreach my $k ( keys %all_valid ) {
		push @out, $k if exists $split{$k};
		delete $split{$k};
	}

	debug("Parsed build targets: " . join(', ', @out));

	if ( %split ) {
		my $bad = join(', ', keys %split);

		print STDERR "Bad value '$bad' for build option, only these values are valid:\n";
		print STDERR  join(', ', sort keys %all_valid) . "\n\n";
		print STDERR "You probably want one of:\n";
		print STDERR "\tclient      Build the graphical desktop client. This is the default.\n";
		print STDERR "\t            Choosing this option builds the 'interface' target\n\n";
		print STDERR "\tserver      Build the components needed to create a server (domain)\n";
		print STDERR "\t            Choosing this option builds domain-server and assignment-client\n\n";
		print STDERR "\tall         Build everything, including development and testing tools\n";
		print STDERR "\nTry $0 --help for more information on the command-line arguments\n";
		exit(1);
	}

	return @out;
}

sub help {
	my $retval = shift // 0;

	print <<HELP;

$0 [options]
Downloads, compiles and installs the Athena Project

Options:
	-B, --build-qt          Built Qt even if there's a binery package
	-C, --collect-info      Collect additional info for debugging
	-D, --distro DIST       Set the distribution
	-d, --destdir DIR       Set the installation directory
	-h, --help              Shows this text
	-j, --cores NUM         Use NUM cores during build
	-k, --keep-source       Don't overwrite the current source tree
	-r, --repo REPO         Set the repository to REPO
	-t, --tag TAG           Set the tag to TAG
	-y, --auto              Run without asking any questions

Custom mode options:

This script is intended to be user friendly and as automatic as possible, so
it has embedded presets for a number of distributions. However, it can be made
to work without them.

	--get-supported         Lists the distributions that are supported
	--get-source-deps DIST  Lists the packages needed to build the source on
	                        distro DIST.
	--get-qt-deps DIST      Lists the packages needed to build Qt on distro
	                        DIST.
	--get-qt-version DIST   Outputs the Qt version that will be used if Qt
	                        is built from source on disto DIST.
	--get-qt-patches DIST   Lists the patches that will be applied if Qt
	                        is built from source on distro DIST.
	--make-pkglist          Reads a list of package names from STDIN and
	                        outputs them in a format suitable for pasting
	                        into the script's source code.

HELP


	exit(1);
	exit($retval);
}
